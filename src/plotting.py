import numpy as np
import arviz as az
import matplotlib.pyplot as plt
import pymc3 as pm
import pandas as pd
import polars as pl
import theano
import seaborn as sns
from statsmodels.stats.power import tt_ind_solve_power
import pyarrow
from src.theory import *


def plot_prior_checks(prior, save_location=False, dpi=300):
    """
    Plots priors checks for our statistical model

    Parameters
    ----------
    prior : pymc3 sample
        Prior sample generated from our model
    save_location: str
        Where to save the generated file.
    dpi:
        Resolution of generated file
    """
    plt.figure(figsize=(8, 4))
    plt.subplot(121)
    az.plot_dist(prior['d_o'], color='orange', label='original prior sim')
    az.plot_dist(prior['d_r'], label='replication prior sim')
    plt.xlabel('Prior predictive effect size')
    plt.ylabel('Density')

    plt.subplot(122)
    plt.scatter(prior['d_o'][45, :], prior['d_r'][45, :])
    plt.xlabel('Prior Sim Original Effect Size')
    plt.ylabel('Prior Sim Replication Effect Size')
    plt.tight_layout()
    if save_location:
        plt.savefig(save_location, dpi=dpi)


def plot_posterior_distribution(i_data, save_loc=False, dpi=300):
    """
    Plots posterior predictive distribution for our model.

    Parameters
    ----------
    i_data :  inferenceData(ArViZ)
        Inference data object generated by PYMC3
    save_loc: str
        Where to save the generated file.
    dpi:
        Resolution of generated file
    """
    sns.set_palette(sns.color_palette("colorblind", n_colors=6))
    az.plot_ppc(i_data)
    plt.tight_layout()
    if save_loc:
        plt.savefig(save_loc, dpi=dpi)


def plot_posterior_predictive(df, ppc, save_loc=False, dpi=300):
    """
    Plots true data vs. posterior estimates.

    Parameters
    ----------
    df :  dataframe
        Raw data after formatting in polars
    ppc : posterior samples
        Posterior predictive samples generated by our model
    save_loc: str
        Where to save the generated file.
    dpi:
        Resolution of generated file
    """
    _, ax = plt.subplots()
    ax.plot(df['d_o'].to_numpy(), df['d_r'].to_numpy(),
            'o', color='orange', alpha=.5, label='Data')
    ax.plot(df['direction'].to_numpy() * ppc['d_o'].mean(axis=0),
            df['direction'].to_numpy() * ppc['d_r'].mean(axis=0), 'o', c='k', alpha=.5, label='Posterior Predictive')
    plt.xlabel('Original Effect Size')
    plt.ylabel('Replication Effect Size')
    plt.legend()
    if save_loc:
        plt.savefig(save_loc, dpi=300)


def plot_fig4a(samples_full, axs, max_effect=2,
               pal=sns.color_palette("colorblind", n_colors=6)):
    """
    Plots figure 4a, kdeplot of model parameters :
    Parameters
    ----------
    samples_full :  pymc3 samples or dictionary
        posterior samples
    axs: matplotlib axis
        Which axis to plot the figure
    pal: seaborn colorpalette
        A color palette used for the plot, must contain at least two colors.
    """

    sns.kdeplot(np.abs(np.array(samples_full['tau']).ravel()), label='True Effect Size', clip=[0, 10],
                shade=True, color=pal[0], ax=axs)
    sns.kdeplot(np.abs(np.array(samples_full['sigma']).ravel()), label='Mediation', clip=[0, 10],
                shade=True, color=pal[1], ax=axs)
    sns.kdeplot(np.abs(np.array(samples_full['bias']).ravel()), label='Inflation', clip=[0, 10],
                shade=True, color='grey', ax=axs)
    axs.legend()
    axs.set_xlim([0, max_effect])
    axs.set_xlabel('Effect size')


def plot_sims(data, y_var, axs, avg_samp, x_var="N", hue='alpha', pal="mako"):
    """
    Plots simulation output :
    Parameters
    ----------
    data :  pandas datafarme
        simulation data
    y_var: str
        Which variable should be on the y-axis
    avg_samp: float
        average sample size (for plotting a dashed vertical line)
    hue: str
        which variable should be used to identify distinct lines
    pal:
        seaborn pallette name (default mako)
    """
    sns.lineplot(x=x_var, y=y_var,
                 hue="alpha",
                 data=data, ax=axs, palette=sns.color_palette(pal, n_colors=5))

    axs.set_ylim(0, 1)
    axs.plot([avg_samp, avg_samp], [0, 1], ls='--')
    axs.set_xlim(np.min(data[x_var]), np.max(data[x_var]))
    axs.set_xlabel('Sample size')
    return axs


def plot_sim_figure(i_data, sim_data, df,
                    plot_medians=True,
                    rep=.39,
                    save_loc=False,
                    dpi=300, max_effect=2, res=100, pal="mako"):
    """
    Plots a full figure for simulations :
    Parameters
    ----------
    i_data :  ArViZ inferencedata object
        inference data from model
    sim_data: pandas dataframe
        Simulation output
    df: polars/pandas dataframe
        Actual replication data
    plot_medians: bool
        Whether to plot true median replication and effect sizes
    rep: float
        proportion of studies that replicated in the original data
    save_loc: str
        Where to save file, assumes directory exists.
    dpi:
        figure resolution
    max_effect:
        Largest effect size in figure
    pal:
        palettte
    """

    # Aesthetics + figure layout
    sns.set_context('paper', font_scale=1)
    sns.set_palette(sns.color_palette(pal))
    fig, axs = plt.subplots(3, 2, figsize=(8, 12))

    # Plot figuer a, set xlim
    plot_fig4a(i_data['posterior'], axs[0][0])
    axs[0][0].set_xlim(0, max_effect)

    # Plot figure item b, publication rate
    plot_sims(sim_data, "publication_rate",
              axs[0][1],
              avg_samp=df['n_o'].median(),
              pal="mako")
    axs[0][1].set_ylabel("P(Publish)")

    # Plot figure item c, effect size
    plot_sims(sim_data, "published_es",
              axs[1][0],
              avg_samp=df['n_o'].median(),
              pal="ch:start=2.8,rot=.3")
    axs[1][0].set_ylabel("Published effect size")

    # Plot median effect size from data, if requested
    if plot_medians:
        axs[1][0].scatter(df['n_o'].median(),
                          df['d_o'].mean())
    axs[1][0].set_ylim(0, max_effect / 2)

    # plot figure item d, replication rate
    plot_sims(sim_data,
              "replication_rate",
              axs[1][1],
              avg_samp=df['n_o'].median(),
              pal="rocket")
    axs[1][1].set_ylabel("P(replicate)")

    # Plot median effect size from data, if requested
    if plot_medians:
        axs[1][1].scatter(df['n_o'].median(), rep)

    # Plot figure item e, type-s error
    plot_sims(sim_data,
              "type_s_error",
              axs[2][0],
              avg_samp=df['n_o'].median(), pal="ch:start=1.3,rot=-.1")
    axs[2][0].set_ylabel("Type-S error")

    # Plot figure item f, reversals
    plot_sims(sim_data,
              "reversals",
              axs[2][1],
              avg_samp=df['n_o'].median(),
              pal="Greys")
    axs[2][1].set_ylabel("P(reversal)")

    # Flatten axes and label with letters, tighten layout
    axs = axs.flat
    import string
    for n, ax in enumerate(axs):
        ax.text(-0.1, 1.1, string.ascii_uppercase[n], transform=ax.transAxes,
                size=20, weight='bold')
    plt.tight_layout()

    # Save
    if save_loc:
        plt.savefig(save_loc, dpi=dpi)
    return axs


def fig_1(save_loc='./output/figures/Figure1.png'):
    pal = sns.color_palette("colorblind", n_colors=6)

    fig = plt.figure(figsize=(8, 4))
    gs = fig.add_gridspec(1, 1)
    ax1 = fig.add_subplot(gs[0, :])
    sns.set_style('white')
    #ax2 = fig.add_subplot(gs[1,0])
    #ax3 = fig.add_subplot(gs[1,1])
    #ax1.plot(np.linspace(0,2,100), stats.norm(0,.2).pdf(np.linspace(0,2,100)),color=pal[0])



    # Add true effect size text

    #Fill distributions for tau, sigma, epislon.
    ax1.fill_between(np.linspace(0, 2, 100),
                     np.zeros(100),
                     stats.norm(0, .2).pdf(np.linspace(0, 2, 100)),
                     color=pal[0], alpha=.5)
    ax1.fill_between(np.linspace(0, 2, 100),
                     np.zeros(100),
                     stats.norm(loc=0.2, scale=0.1).pdf(np.linspace(0, 2, 100)) / 2, color=pal[1], alpha=.3)

    ax1.fill_between(np.linspace(0, 2, 100),
                     np.zeros(100),
                     stats.norm(loc=0.3, scale=0.03).pdf(np.linspace(0, 2, 100)) / 20, color=pal[2], alpha=.3)

    #Label Distributions
    ax1.plot([0, .2], [1.2, 1.2], color='k')
    ax1.text(x=.1, y=1.25, s=r'$\tau$', fontsize='x-large', color='k')



    ax1.plot([.2, .2], [0, 2], color='k', ls='--')
    ax1.text(x=.28, y=1.25, s=r'$\sigma$', fontsize='x-large', color='k')

    ax1.text(x=.31, y=.1, s=r'$\frac{\epsilon}{\sqrt{n}}$', fontsize='x-large')
    ax1.plot([0.3, .34], [0.27, 0.27], color='k')

    #Add line for d_true
    ax1.plot([0.2, .31], [1.1, 1.1], color='k')
    ax1.text(x=.2, y=2.1, s=r'$d_{true}$', fontsize='x-large')

    #Add line for original effect size
    ax1.plot([0.1, 0.1], [0, stats.norm(loc=0.25, scale=0.1).pdf(
        0.1) / 2], ls='--', color='k', zorder=3)
    ax1.text(x=.25, y=.73, s=r'$d_{original}$', fontsize='x-large')

    #Add line for replication effectsize and label
    ax1.plot([0.3, 0.3], [0, stats.norm(
        loc=0.25, scale=0.1).pdf(0.4) / 2], ls='--', color='k')
    ax1.text(x=.05, y=.73, s=r'$d_{replication}$', fontsize='x-large')

    #Add line for t_crit and label
    ax1.plot([.22, .22], [0, .4], color='k')
    ax1.text(x=.21, y=.43, s=r'$t_{crit.}$', fontsize='x-large')


    #Add annotations
    plt.annotate("Average hypothesized effect size",
                 xy=(0.13, 1.3), xytext=(.5, 1.8),
                 arrowprops=dict(headwidth=10, headlength=10,
                                 width=0.1, color='k'),
                 fontsize='large')

    plt.annotate("Variation in observed effects", xy=(0.31, 1.30), xytext=(.5, 1.0),
                 arrowprops=dict(headwidth=10, headlength=10,
                                 width=0.1, color='k'),
                 fontsize='large')

    plt.annotate("Measurement Error", xy=(0.35, .12), xytext=(.45, 0.1),
                 arrowprops=dict(headwidth=10, headlength=10,
                                 width=0.1, color='k'),
                 fontsize='large')

    ax1.set_xticks(np.linspace(0, 1, 11))
    ax1.set_xlim(0, .8)
    ax1.set_ylim(0, 2.3)
    ax1.set_xlabel('Effect size')
    ax1.set_ylabel('Density')
    plt.tight_layout()

    plt.savefig(save_loc, dpi=300, transparent=False)
    return fig


def fig_2(N=100, res=40, output='./output/figures/figure2.png'):
    sns.set_context('paper', font_scale=1)
    sns.set_palette(sns.color_palette("mako"))

    fig, axs = plt.subplots(2, 2, figsize=(8, 8))
    axs0 = axs[0][0]
    sns.set_context('paper')

    # 2A
    # Calculate meshgrid
    x = np.linspace(0, 1.0, res)
    y = np.linspace(0, 1.0, res)
    X, Y = np.meshgrid(x, y)
    Z = publish_vec(tau=X, sigma=Y, epsilon=1, n=N)
    # Plot colormap
    lls = np.linspace(.2, 1, 9)
    CS = axs0.contour(X, Y, Z, levels=lls, zorder=2, colors='white')
    axs0.clabel(CS, colors='w', fontsize=12)  # contour line labels
    levels = np.linspace(.0, 1, 1000)
    CSF = axs0.contourf(X, Y, Z, zorder=1, levels=levels,
                        cmap=sns.color_palette("mako", as_cmap=True))
    axs0.set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs0.set_xlabel(r'$\tau$' + ' (effect size)')
    axs0.set_title('Pr(publish)\n' + 'N=' + str(N) + ', ' + r'$\epsilon=1$')

    # 2B
    # Set Axis
    axs1 = axs[0][1]
    # Calculate mesh grid
    x = np.linspace(0, 1.0, res)
    y = np.linspace(0, 1.0, res)
    X, Y = np.meshgrid(x, y)
    Z = replicate_vec(X, Y, 1, N, .05)
    # Plot colormap
    CS = axs1.contour(X, Y, Z, levels=lls, zorder=2, colors='white')
    axs1.clabel(CS, colors='w', fontsize=12)  # contour line labels
    levels = np.linspace(.0, 1, 100)
    CSF = axs1.contourf(X, Y, Z, zorder=1, levels=levels,
                        cmap=sns.color_palette("rocket", as_cmap=True))
    axs1.set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs1.set_xlabel(r'$\tau$' + ' (effect size)')
    axs1.set_title('Pr(replicate)\n' + 'N=' + str(N) + ', ' + r'$\epsilon=1$')

    # 2C
    # Calculate mesh grid
    x = np.linspace(0, 1.0, res)
    n = np.linspace(30, 1000, res)
    N, X = np.meshgrid(n, x)
    Z = publish_vec(tau=0.2, sigma=X, epsilon=1, n=N)
    # Plot colormap
    lls = np.linspace(.2, 1, 9)
    CS = axs[1][0].contour(N, X, Z, levels=lls, zorder=2, colors='white')
    axs[1][0].clabel(CS, colors='w', fontsize=12)  # contour line labels
    levels = np.linspace(.0, 1, 1000)
    axs[1][0].plot([30, 1000], [.2, .2], color='k', ls='--', alpha=.5)
    CSF = axs[1][0].contourf(
        N, X, Z, zorder=1, levels=levels, cmap=sns.color_palette("mako", as_cmap=True))
    axs[1][0].set_ylabel(r'$\sigma$' + ' (varying effects)')
    # \n' +'N='+str(N) + ', ' + r'$\epsilon=1$')
    axs[1][0].set_title('Pr(publish)')
    axs[1][0].set_xlabel('Sample size')

    # 2D
    # Calculate mesh grid
    x = np.linspace(0, 1.0, res)
    n = np.linspace(30, 1000, res)
    N, X = np.meshgrid(n, x)
    # Plot colormap
    Z = replicate_vec(tau=0.2, sigma=X, epsilon=1, n=N)
    lls = np.linspace(.2, 1, 9)
    CS = axs[1][1].contour(N, X, Z, levels=lls, zorder=2, colors='white')
    axs[1][1].clabel(CS, colors='w', fontsize=12)  # contour line labels
    levels = np.linspace(.0, 1, 1000)
    CSF = axs[1][1].contourf(N, X, Z, zorder=1, levels=levels,
                             cmap=sns.color_palette("rocket", as_cmap=True))
    axs[1][1].set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs[1][1].set_xlabel('Sample size')
    # \n' +'N='+str(N) + ', ' + r'$\epsilon=1$')
    axs[1][1].set_title('Pr(replicate)')
    axs[1][1].plot([30, 1000], [.2, .2], color='k', ls='--', alpha=.5)

    # Label subplots alphabetically
    axs = axs.flat
    import string
    for n, ax in enumerate(axs):
        ax.text(-0.1, 1.1, string.ascii_uppercase[n], transform=ax.transAxes,
                size=20, weight='bold')

    # Fix layout
    plt.tight_layout()
    # Save figure, return
    plt.savefig('./output/figures/figure2.png', dpi=300)
    return fig, axs


def fig_3(N=100, res=40, output='./output/figures/figure3.png'):

    fig, axs = plt.subplots(2, 2, figsize=(8, 8))
    x = np.linspace(0.01, 1, res)
    y = np.linspace(0.01, 1, res)
    X, Y = np.meshgrid(x, y)
    Z = type_s_vec(X, Y, 1, N, .05)

    lls = np.linspace(0, .5, 6)
    CS = axs[0][0].contour(X, Y, Z, zorder=2, levels=lls, colors='white')
    axs[0][0].clabel(CS, colors='w', fontsize=12)  # contour line labels

    levels = np.linspace(0, .5, 100)
    CSF = axs[0][0].contourf(X, Y, Z, zorder=1, levels=levels, cmap=sns.color_palette(
        "ch:start=2.8,rot=.3", as_cmap=True))
    axs[0][0].set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs[0][0].set_xlabel(r'$\tau$' + ' (effect size)')
    axs[0][0].set_title('Pr(Type-S)')  # N=50, ' + r'$\epsilon=1$')

    x = np.linspace(0.01, 1, res)
    y = np.linspace(0.01, 1, res)
    X, Y = np.meshgrid(x, y)

    Z = type_m_vec(X, Y, 1, N, .05)

    lls = np.logspace(0, 4, 5, base=2)
    CS = axs[0][1].contour(X, Y, Z, zorder=2, levels=lls, colors='white')
    axs[0][1].clabel(CS, colors='w', fontsize=12)  # contour line labels

    levels = np.logspace(0, 8, 1000, base=2) - 1
    CSF = axs[0][1].contourf(X, Y, Z, zorder=1, levels=levels,
                             norm=mpl.colors.LogNorm(vmin=.5, vmax=16),
                             cmap=sns.color_palette("ch:start=1.3,rot=-.1", as_cmap=True))

    axs[0][1].set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs[0][1].set_xlabel(r'$\tau$' + ' (effect size)')
    axs[0][1].set_title('Type-M error')  # N=50, ' + r'$\epsilon=1$')
    axs[0][1].fill_between([0, 1], [1, 1], color='k', zorder=-1)
    axs[0][1].set_ylim(0.01, 1)
    axs[0][1].set_xlim(0.01, 1)

    x = np.linspace(0, 1.0, res)
    n = np.linspace(30, 1000, res)
    N, X = np.meshgrid(n, x)
    Z = type_s_vec(tau=0.2, sigma=X, epsilon=1, n=N)

    lls = np.linspace(0, .5, 6)
    CS = axs[1][0].contour(N, X, Z, levels=lls, zorder=2, colors='white')
    axs[1][0].clabel(CS, colors='w', fontsize=12)  # contour line labels
    levels = np.linspace(.0, .5, 1000)
    axs[1][0].plot([30, 1000], [.2, .2], color='k', ls='--', alpha=.5)
    CSF = axs[1][0].contourf(N, X, Z, zorder=1,
                             levels=levels, cmap=sns.color_palette("ch:start=2.8,rot=.3", as_cmap=True))
    axs[1][0].set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs[1][0].set_title('Pr(Type-S)')  # N=50, ' + r'$\epsilon=1$')
    axs[1][0].set_xlabel('Sample size')
    axs[1][0].set_xlim((30, 1000))

    x = np.linspace(0, 1.0, res)
    n = np.linspace(30, 1000, res)
    N, X = np.meshgrid(n, x)
    Z = type_m_vec(tau=0.2, sigma=X, epsilon=1, n=N)
    lls = np.array([1, 1.5, 2, 3, 4, 5, 6, 7, 8])
    CS = axs[1][1].contour(N, X, Z, levels=lls, zorder=2, colors='white')
    axs[1][1].clabel(CS, colors='w', fontsize=12)  # contour line labels
    levels = np.linspace(0, 10, 1000)
    CSF = axs[1][1].contourf(N, X, Z, zorder=1, levels=levels, cmap=sns.color_palette(
        "ch:start=1.3,rot=-.1", as_cmap=True))
    axs[1][1].set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs[1][1].set_xlabel('Sample size')
    axs[1][1].set_title('Type-M')  # N=50, ' + r'$\epsilon=1$')
    axs[1][1].plot([30, 1000], [.2, .2], color='k', ls='--', alpha=.5)
    axs[1][1].set_xlim((30, 1000))

    import string
    axs = axs.flat
    for n, ax in enumerate(axs):
        ax.text(-0.1, 1.1, string.ascii_uppercase[n], transform=ax.transAxes,
                size=20, weight='bold')

    plt.tight_layout()
    plt.savefig(output, dpi=300)


def SI_Theory_Fig1(N=100, res=40, p_true=.1,
                   output='./output/figures/figure3.png'):

    sns.set_context('paper', font_scale=1)
    sns.set_palette(sns.color_palette("mako"))

    fig, axs = plt.subplots(1, 3, figsize=(12, 4))

    p_true = .1

    axs0 = axs[0]
    sns.set_context('paper')
    x = np.linspace(0, 1.0, res)
    y = np.linspace(0.01, 1.0, res)
    X, Y = np.meshgrid(x, y)
    Z1 = publish_vec(tau=0.01, sigma=Y, epsilon=1, n=N)
    Z2 = publish_vec(tau=X, sigma=Y, epsilon=1, n=N)
    Z = p_true * Z1 + (1 - p_true) * Z2

    lls = np.linspace(.2, 1, 9)
    CS = axs0.contour(X, Y, Z, levels=lls, zorder=2, colors='white')
    axs0.clabel(CS, colors='w', fontsize=12)  # contour line labels
    levels = np.linspace(.0, 1, 1000)
    CSF = axs0.contourf(X, Y, Z, zorder=1, levels=levels,
                        cmap=sns.color_palette("mako", as_cmap=True))
    axs0.set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs0.set_xlabel(r'$\tau$' + ' (effect size)')
    axs0.set_title('Pr(publish)\n' + 'N=100, ' + r'$\epsilon=1$')

    axs1 = axs[1]
    x = np.linspace(0, 1.0, res)
    y = np.linspace(0, 1.0, res)
    X, Y = np.meshgrid(x, y)
    Z1 = replicate_vec(X, Y, 1, N, .05)
    Z2 = replicate_vec(0.01, Y, 1, N, .05)
    Z = p_true * Z1 + (1 - p_true) * Z2

    CS = axs1.contour(X, Y, Z, levels=lls, zorder=2, colors='white')
    axs1.clabel(CS, colors='w', fontsize=12)

    levels = np.linspace(.0, 1, 100)
    CSF = axs1.contourf(X, Y, Z, zorder=1, levels=levels,
                        cmap=sns.color_palette("rocket", as_cmap=True))
    axs1.set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs1.set_xlabel(r'$\tau$' + ' (effect size)')
    axs1.set_title('Pr(replicate)\n' + 'N=100, ' + r'$\epsilon=1$')

    x = np.linspace(0.001, 1, res)
    y = np.linspace(0.001, 1, res)
    X, Y = np.meshgrid(x, y)
    Z1 = type_s_vec(X, Y, 1, N, .05)
    Z2 = type_s_vec(0.01, Y, 1, N, .05)
    Z = p_true * Z1 + (1 - p_true) * Z2

    lls = np.linspace(0, .5, 11)
    CS = axs[2].contour(X, Y, Z, zorder=2, levels=lls, colors='white')
    axs[2].clabel(CS, colors='w', fontsize=12)  # contour line labels

    levels = np.linspace(0, .5, 100)
    CSF = axs[2].contourf(X, Y, Z, zorder=1, levels=levels, cmap=sns.color_palette(
        "ch:start=2.8,rot=.3", as_cmap=True))
    axs[2].set_ylabel(r'$\sigma$' + ' (varying effects)')
    axs[2].set_xlabel(r'$\tau$' + ' (effect size)')
    axs[2].set_title('Type-S error')

    import string
    axs = axs.flat
    for n, ax in enumerate(axs):
        ax.text(-0.1, 1.1, string.ascii_uppercase[n], transform=ax.transAxes,
                size=20, weight='bold')

    plt.tight_layout()
    plt.savefig(output, dpi=300)
    return fig
